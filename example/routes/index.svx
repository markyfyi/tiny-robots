Tiny Robots is a frontend build system and anti-framework built on top of [Svelte](https://svelte.dev/blog/svelte-3-rethinking-reactivity#What_is_Svelte) designed help you get things done and ship ambitious web apps quickly.

### Features üåà

- Fast dev mode, fast build step, fast runtime.
- A minimal surface area - less code you have to remember.
- üî• Ultrafast hot module replacement¬π. üî• Seriously, we're talking really frickin' fast. Tiny Robots uses [Snowpack](https://www.snowpack.dev/) in development mode, so hot-swapping completes in the order of milliseconds and stays that way no matter how large your app gets.
- Configurable universal data fetching. Routes can be loaded eagerly or wait until their data is loaded.
- Static site generation with dynamic data loading. Just run `yarn run tr export`.
- Client side routing with automatic data fetching.
- Filesystem-based routing, with directory-based layouts and global app layout.
- Global CSS/JS support for stuff like vendor code or analytics. Just create a `global` directory and all of it's contents will get inlined into every page.
- Markdown in your Svelte with [mdsvex](https://mdsvex.com/).

¬πWhat's hot module replacement? Here's the definition [straight from Snowpack](https://www.snowpack.dev/concepts/hot-module-replacement):

> _Hot Module Replacement (HMR) is the ability to push file updates to the browser without triggering a full page refresh. Imagine changing some CSS [or JavaScript, or a Svelte file], hitting save, and then instantly seeing your change reflected on the page without a refresh. That‚Äôs HMR._

### Project goals ü§ñ

Tiny Robots embraces [Svelte's philosophy](https://svelte.dev/blog/write-less-code), and attempts to explore what applying those principles up the stack could look like. It borrows a lot of ideas from [Next.js](https://nextjs.org/) and [Sapper](https://sapper.svelte.dev/), but tries to keep a minimal footprint.

Tiny Robots aims to:

- Get out of your way.
- Empower code authors with an instantaneous feedback loop.
- Do the grunt work and write the boring code for you.
- Be predictable, and easy to debug when it's not.
- Generate extremely fast, performant bundles.
- Invest in [ES modules](https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/) and the future of web technologies.

_Check out the code for this site [here](https://github.com/mkshio/tiny-robots/tree/master/example)._

> **Author's note:** üèóÔ∏è This project is a week old. It has bugs. It has random console-logs. It has no respect for SemVer (_not yet, sorry!_). It will have random breaking changes. It will have some bad ideas in it. But this project is ambitious, so please be kind and help where you can. Thanks!

---

### 1. Setup üì¶

```shell
# a simple setup
yarn add tiny-robots # or npm install tiny-robots
mkdir routes && touch routes/index.svelte # your first route

# create special directories
yarn run tr init
# --- or ---
mkdir static # optional - static assets (images, fonts) go here
touch index.html # optional - an HTML shell
mkdir global # optional - global css/j"s files go here; they'll automatically be inlined
```

### 2. Develop üë©üèΩ‚Äçüíª

```shell
yarn run tr
```

Runs your app with [Snowpack](https://www.snowpack.dev/).

### 3. Ship üöÄ

```shell
yarn run tr export
```

Generates an `./export` directory containing production-ready static HTML pages and JS bundles using [Rollup](https://rollupjs.org/guide/en/).

Adding `--dev` will produce a build for diagnostics. Presently, it generates an un-minified bundle, but more features may be added under this flag in the future.

---

### Moving parts

#### Routes

Tiny Robots rocks PHP-style filesystem-based routing. Just create a file in the `routes` directory and navigate to it in your browser, and Tiny Robots will render the file for you.

Some examples of URL-to-file resolution:

- `/` ‚Üí `/routes/index.svelte`
- `/page` ‚Üí `/routes/page.svelte`
- `/subpath/` ‚Üí `/routes/subpath/index.svelte`
- `/subpath/page` ‚Üí `/routes/subpath/page.svelte`

#### Layouts with `_layout.svelte`

You may optionally create a `_layout.svelte` to act as a wrapper component around every file in that directory.

For example, if you create a file at the path `/routes/mypath/myfile.svelte`, Tiny Robots will search for a file `/routes/mypath/_layout.svelte` to act as a layout for that page.

Layouts must render a default `<slot />` (a [Svelte concept](https://svelte.dev/tutorial/slots)) as a render target for the current page.

#### App layout with `_app.svelte`

You may additionally create a file in the root of your `routes` directory named `_app.svelte`, which will in turn wrap every page (including that pages layout).

Like their layout cousins, app layouts must also render a default `<slot />`.

#### Data fetching with `prefetch`

```html
<script context="module">
  export async function prefetch({
    params, // object, client-side only - the query parameters from the current url
    static, // boolean - whether this function is being called in export phase
  }) {
    // fetch from your API and
    // return a promise of the component's props
    return Promise.resolve({ someProp: 1, someOtherProp: 2 });
  }
</script>

<script>
  export let someProp;
  export let someOtherProp;
</script>
```

By default, both server-side builds and client navigation will wait to render until the prefetch promise resolves.

Components can optionally export a module-level flag to mark itself as "eager" (`export let eager = true;`). When navigating to an eager component on the client, the router will immediately render the page without any prefetched props, then update it once the prefetch resolves.

Tiny Robots also injects props named `loading` and `fetching` into every component (including `_layout` and `_app`) to allow the UI to display interstitial states. `loading` indicates that the app is int he middle of a route transition, and `fetching` indicates the app is waiting route in question's `prefetch` call. Note, `loading` and `fetching` can be simultaneously true.

#### Static assets

If you depend on any images, fonts, stylesheets or other files stash them in a directory in your project's root called `static`. Tiny Robots will copy the contents of `static` into it's generated export directory.

#### Global assets

Sometimes we inherit code that, for one reason or another, can't or shouldn't be bundled:

- Non-modularized assets
- Vendor libraries
- Analytics
- Polyfills
- CSS resets or global themes
- jQuery or Wordpress plugins (hey, no judgement here)
- Code hastily copy/pasted from Stack Overflow üòÖ

Tiny Robots will detect the presence of a `global` directory in your project root, and automatically inline all of the code from each file in said directory into every HTML page created during export.

Presently, it only supports plain JavaScript and CSS.

Note: unlike static assets, global assets aren't available in the `export` directory.

---

### WIP/Roadmap üèó

#### Pending

- Differentiate and persist build-time data fetching in SPA mode.
- SEO defaults with svelte-seo.
  - Meta tags.
  - Social cards.
  - Sitemaps.
- Better CSS extraction.
- Dynamic routes.
  - "Get static routes" capability.
- Plain 'ol JS routes.

#### Coming soon

- Error pages.
  - Error recovery in dev.
- npx/yarn `create-*-app` command
- Generators for Netlify/Vercel/etc.
  - "Deploy on X" buttons.
  - Slugs, catchall routes and URL rewrites.
  - Abstraction for lambdas.
- TypeScript support.
- Remove console noise.
- More HTML features.
  - Partials.
  - Merge head/body with template/layouts.
- Route asset preloads on page transition.
  - Image preloads.
    - Add images to manifest.
  - Scan for hrefs to other pages and preload their js/css/pages.
- PWA/service worker.
- Per-component rehydration opt-out (i.e. server-only components).
- SSR mode.
  - Vercel runtime integration.
  - Server hooks.
- Experiment: Support for React pages.
- Experiment: esbuild for production.
